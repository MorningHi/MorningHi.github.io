{"meta":{"title":"Something for Nothing","subtitle":"","description":"","author":"Rezero","url":"https://MorningHi.github.io"},"pages":[{"title":"","date":"2019-08-20T02:27:27.810Z","updated":"2019-08-20T02:27:27.810Z","comments":true,"path":"404.html","permalink":"https://MorningHi.github.io/404.html","excerpt":"","text":""},{"title":"About me","date":"2017-06-23T07:11:57.000Z","updated":"2019-08-20T02:27:27.810Z","comments":true,"path":"about/index.html","permalink":"https://MorningHi.github.io/about/index.html","excerpt":"","text":"一只喜欢看日落的猴子 From XDU"},{"title":"tags","date":"2017-06-22T16:58:21.000Z","updated":"2019-08-20T02:27:27.810Z","comments":false,"path":"tags/index.html","permalink":"https://MorningHi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"binarySearchTree","slug":"binarySearchTree","date":"2019-09-22T09:14:52.000Z","updated":"2019-09-22T09:14:52.749Z","comments":false,"path":"2019/09/22/binarySearchTree/","link":"","permalink":"https://MorningHi.github.io/2019/09/22/binarySearchTree/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"https://MorningHi.github.io/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"https://MorningHi.github.io/categories/分类1/分类2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://MorningHi.github.io/tags/标签1/"},{"name":"标签2","slug":"标签2","permalink":"https://MorningHi.github.io/tags/标签2/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"https://MorningHi.github.io/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"https://MorningHi.github.io/categories/分类1/分类2/"}]},{"title":"十大排序算法总结","slug":"sort","date":"2019-08-29T13:22:22.000Z","updated":"2019-08-30T05:20:03.710Z","comments":false,"path":"2019/08/29/sort/","link":"","permalink":"https://MorningHi.github.io/2019/08/29/sort/","excerpt":"","text":"定义&emsp;&emsp;排序 是计算机内部经常进行的一项操作，目的是将一组无序的序列调整为一组有序的序列。Excel中将数据按照名称进行升序降序排列就是一种常见的排序操作。 相关概念 时间复杂度：反映操作次数(计算量)随数据长度的变化规律，是数据规模的函数，用$O(·)$表示。 空间复杂度：用来度量执行算法所需的存储空间随数据规模的变化情况，也用$O(·)$表示。 稳定性：对于两个相等的元素 $a$ 和 $b$，如果排序算法不会改变他们的相对位置，则称排序算法是稳定的，否则这个算法就是不稳定的。 分类&emsp;&emsp;根据排序过程是否需要使用外部存储空间可以将排序算法分为内部排序和外部排序。 &emsp;&emsp;根据排序算法的复杂度和是否是基于对元素进行比较进行排序又可以将算法分为非线性时间比较类排序和线性时间非比较类排序。 非线性时间比较类排序：顾名思义就是根据比较来确定元素的排列顺序的排序算法，时间复杂度最低为$(O(nlogn))$ 线性时间非比较类排序：不通过比较元素的相对大小来确定元素的排列顺序的算法，时间复杂度可以突破对数级别以线性时间运行。 比较 &emsp;&emsp;表中 $k$ 表示所需的桶(bucket)的个数——对于计数排序、桶排序和基数排序三种排序算法需要额外的“buckets”来辅助排序。 具体算法介绍下面具体介绍了每一种排序算法： (1) 简单选择排序 (2) 冒泡排序 (3) 插入排序 (4) 希尔排序 (5) 归并排序 (6) 快速排序 (7) 堆排序 (8) 计数排序/桶排序/基数排序 &emsp;&emsp;所有的排序都默认是按照从大到小的顺序进行排序，完整的代码可以在我的github上下载。此外，文章中的所有演示动图都来自于互联网。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"},{"name":"排序算法","slug":"排序算法","permalink":"https://MorningHi.github.io/tags/排序算法/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"计数排序/桶排序/基数排序","slug":"CountingSort","date":"2019-08-26T08:54:24.000Z","updated":"2019-08-30T05:20:03.700Z","comments":false,"path":"2019/08/26/CountingSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/26/CountingSort/","excerpt":"","text":"&emsp;&emsp;计数排序、桶排序和基数排序是三个线性时间非比较类排序算法，他们相同的特点在于不是通过比较元素的大小来确定他们的排列顺序，并且均能够达到线性时间复杂度$O(n+k)$，之所以这样根本在于他们都使用了额外的桶(bucket, 不是某种特定数据结构，只是一种叫法)来辅助存储数据。但是这三种排序算法的应用场景都比较有限，下面具体来讲一下这三种排序算法。 计数排序基本思想&emsp;&emsp;以一个整数数列为例，如果我们知道它的最大值和最小值，那么也就意味着数组中的所有元素都位于 [最小值，最大值] 这个区间，我们对这个区间的每一个数在数组中出现的次数，然后在从小到大展开，这样就完成了排序，这就是计数排序(counting sort)的基本思想。可以看到，计数排序不通过比较元素的大小关系来进行排序，因此是一种非比较类排序算法。 算法流程 首先遍历数组找出最大值maxValue和最小值minValue，并根据最大最小值确定需要的桶(bucket)的个数 maxValue-minValue+1，这样每个桶就对应[minValue, maxValue]中的一个值； 遍历数组计数[minValue, maxValue]中每一个值在数组中出现的次数，存放到对应的桶中； 释放桶，每个位置的数字放回原数组。 演示 代码实现&emsp;&emsp;计数排序的代码如下。这里使用了数组中最大最小值来确定需要的桶的个数，也有程序直接默认0为数组的最小值，但这样就无法处理带负数的数组，同时对于最小值远大于0的非负数组也会造成空间浪费。 1234567891011121314151617181920212223242526public static void counting_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int maxValue = arr[0], minValue = arr[0]; // 找出最大最小值 for(int n : arr)&#123; if(n &gt; maxValue) maxValue = n; else if(n &lt; minValue) minValue = n; &#125; int bucketLen = maxValue - minValue + 1; // 需要的桶的个数 int[] bucket = new int[bucketLen]; for(int n : arr)&#123; // 桶中每个位置用来计数原数组中等于\"当前桶索引+minValue\"的数的个数 bucket[n-minValue]++; &#125; int sortedIndex = 0; // 将桶里的元素放回原数组 for(int i = 0; i &lt; bucketLen; i++)&#123; while(bucket[i]-- &gt; 0)&#123; arr[sortedIndex++] = i + minValue; &#125; &#125;&#125; 分析 时间复杂度 计数排序中共有三个for循环，前两个循环都是从前向后遍历数组，时间复杂度为 $O(n)$，第三个for循环从桶中取回元素到数组中，时间复杂度为 $O(n+k)$ ，其中 $k$ 是需要的桶的个数。总的来说基数排序的时间复杂度为 $O(n+k)$ ，最好最坏情况下都为 $O(n+k)$ 。 空间复杂度 计数排序使用了额外的长度为 $k$ 的数组来存放计数结果，空间复杂度为 $O(k)$。 稳定性 计数排序是稳定的排序算法。 桶排序基本思想&emsp;&emsp;桶排序和计数排序的思路很象，只不过计数排序的“桶”只是用来计数每个元素的次数，而桶排序中的“桶”是真实存放元素的。桶排序中每个桶都是一个可以存放元素的容器，用来将原数组中的元素按照一定的映射规则放到桶里并且满足第 $i$ 个桶里的元素均小于第 $j$ 个桶里的元素($i&lt;j$)，然后对每一个桶里的元素分别进行排序，这样在所有的桶排序完成后再将元素取出放回到原数组。 算法流程 首先根据元素范围和映射规则确定需要使用的桶的个数 $k$ ; 遍历数组并根据映射规则将每个元素放到对应的桶中； 对每个桶中的元素单独进行排序； 待所有桶中的元素均排序完成后，将元素依次放回原数组，排序完成。 &emsp;&emsp;上面一直在提一个“映射规则”，这个映射规则的目的就是确定某个元素应该被放到哪个桶里，从而当 $i&lt;j$ 时满足第 $i$ 个桶里的元素均小于第 $j$ 个桶里的元素，这样保证在所有桶里元素均排序完成后将元素放回数组也是有序的。 &emsp;&emsp;映射规则是人为设计的具体来说，如果我们预设桶的容量为 $m$，也就是每个桶中最多存放 $m$ 个元素，假设数组最大值和最小值分别为 $max$ 和 $min$，那么桶排序需要的桶的个数就为 $(max-min)/m$，接下来通过以下映射确定元素 $x$ 应当被放到哪个桶中： i=\\frac{x-min}{m}可以理解为我们将 $[min,max]$ 区间划分为了 $k$ 个连续的子区间，然后将数组中的数放到所属的区间内，接下来对每个区间内的数单独排序，最后使得整个数组有序。 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041public static void bucket_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int bucketSize = 10; // 设定桶的容量 int maxValue = arr[0], minValue = arr[0]; // 找出最大最小值 for(int n : arr)&#123; if(n &gt; maxValue) maxValue = n; else if(n &lt; minValue) minValue = n; &#125; // 创建桶的集合 ArrayList&lt;LinkedList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(); int bucketLen = (int)Math.floor((maxValue - minValue) / bucketSize) + 1; // 需要的桶的个数 for(int i = 0; i &lt; bucketLen; i++)&#123; buckets.add(new LinkedList&lt;Integer&gt;()); &#125; // 将数组中的元素根据所处区间放到桶中 for(int n : arr)&#123; int index = (int)Math.floor((n - minValue) / bucketSize); // 确定当前元素应该放到第几个桶中 buckets.get(index).add(n); &#125; // 对每个桶中的元素进行排序 for(LinkedList&lt;Integer&gt; bucket : buckets)&#123; if(bucket.size() &gt; 1)&#123; Collections.sort(bucket); // 桶中元素大于1才需要排序 &#125; &#125; // 从桶中按顺序取出元素放回数组 int index = 0; for(LinkedList&lt;Integer&gt; bucket : buckets)&#123; for(int n : bucket)&#123; arr[index++] = n; &#125; &#125;&#125; &emsp;&emsp;对于每个桶中元素单独排序的时候，由于桶的容量较小，因此使用像插入排序之类的基础排序方法性能也比较好。(代码中作弊使用了java自带的排序函数) 分析 时间复杂度 桶排序的平均时间复杂度为 $O(n+k)$ ，最好的时间复杂度为 $O(n+k)$ ，最坏的情况下时间复杂度为 $O(n^2)$。 当 $k==n$ 时，桶排序就变成了计数排序；当 $k==1$ 时，所有元素放在一个桶里，桶排序就演化成了内部排序的实现方式。 空间复杂度 桶排序使用了 $k$ 个桶来存放数组的所有元素，空间复杂度为 $O(n+k)$。 稳定性 桶排序的稳定性取决于内部排序算法。 基数排序基本思想&emsp;&emsp;基数排序是另一种使用了桶来辅助排序的非比较类排序。从直观上来讲，对于一个均为正数的整型数组，每个数字的每一位都是0-9中的某个数字。这样我们从最低位(个位)开始将每个数字放到最低位数字对应的桶中(编号0-9)，这样按桶的顺序得到一个新排列的数组，接下来按照十位的数字再放到相应桶中，一直到最高位，最终就得到一个有序的数组。 算法流程这里以一个元素均为正整数的数组为例，基数排序的步骤如下： 遍历数组，找出数组中最大数的位数； 生成编号为0-9的桶用来存放元素； 遍历数组，得到每个数字最低位的数字 $i$，将这个数放入编号为 $i$ 的桶中； 按桶的编号顺序将桶中的元素放回数组； 遍历数组，得到每个元素的次低位元素，按照步骤3的规则放入对应的桶中； 按照同样的方式依次得到每个元素更高位的数，放入桶中，再按序放回数组，直到处理完最大数的最高位。 演示&emsp;&emsp;上图演示了最高位数为两位的正整数排序过程，对于更大的数，使用相同的方法不断将元素放到桶中再取出就可以达到排序的效果。 代码实现&emsp;&emsp;首先从最基础的待排序元素均为非负整数的排序过程来看，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 public static void radix_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int maxBit = getMaxBit(arr); // 计算数组中最大的数的位数 int bitCount = 0, div = 1, mod = 10; while(bitCount++ &lt; maxBit)&#123; // 生成桶集合，共10个桶代表0-9的数字 ArrayList&lt;Integer&gt;[] buckets = new ArrayList[10]; for(int i = 0; i &lt; 10; i++)&#123; buckets[i] = new ArrayList&lt;Integer&gt;(); &#125; for(int n : arr)&#123; // (n%mod)/div取每个数当前位的值：0-9 int current = (n % mod) / div + 10; buckets[current].add(n); // 根据当前位的数将元素放入对应的桶中 &#125; // 将桶中的数放回数组 int index = 0; for(int i = 0; i &lt; 10; i++)&#123; if(!buckets[i].isEmpty())&#123; for(int n : buckets[i])&#123; arr[index++] = n; &#125; &#125; &#125; div *= 10; mod *= 10; &#125; &#125;private static int getMaxBit(int[] arr)&#123; int maxValue = arr[0], bit = 0; for(int n : arr)&#123; if(n &gt; maxValue) maxValue = n; // 找出数组中最大的数 &#125; while(maxValue &gt; 0)&#123; bit++; maxValue /= 10; &#125; return bit;&#125; getMaxBit(int[] arr)函数用来得到数组中最大数的位数。同时需要注意在获取每个元素当前位的数时不能改变元素的值，在代码中通过两行元素实现： 12int current = (n % mod) / div + 10;buckets[current].add(n); 初始 mod=10，div=1，以152为例，第一次循环得到个位的值为 (152 % 10)/1 = 2，每次循环之后mod和div均变为原来的十倍，这样取十位的值就是： (152 % 100)/10 = 5，取百位的值就是 (152 % 1000)/100 = 1. &emsp;&emsp;但是上面的程序只能处理非负元素序列的排序，对于有符号的整数序列需要做出一定的修改。一种思路是将负数先按其绝对值进行排序，最后再对负数部分排列就可以。另一种思路就是扩展桶的数量的实现，对于非负整数我们用编号为0-9的桶来存放元素，那么对于有符号整数我们也可以用编号为0-18的19个桶来存放元素，每次取元素当前位值的同时带上元素的符号，这样0-8号桶存放当前位为 -9到-1的元素，9-18号桶存放当前位为0-9的元素。此外还要注意最大位数需要根据绝对值最大的元素来决定。 举个栗子：对于58和-128，首先确定最大位数为3，首先取个位值分别为8和-8，分别属于17号和1号桶，十位值分别为5和-2，分别属于14号桶和7号桶，百位值为0和-1，分别属于9号桶和8号桶。具体实现程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void radix_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int maxBit = getMaxBit(arr); // 计算数组中最大的数的位数 int bitCount = 0, div = 1, mod = 10; while(bitCount++ &lt; maxBit)&#123; // 生成桶集合，共19个桶，0-8存放负数，9-18存放正数 @SuppressWarnings(\"unchecked\") ArrayList&lt;Integer&gt;[] buckets = new ArrayList[19]; for(int i = 0; i &lt; 19; i++)&#123; buckets[i] = new ArrayList&lt;Integer&gt;(); &#125; for(int n : arr)&#123; /* * (n%mod)/div取每个数当前位的值,这个值带符号 * 然后 +9，将原本的负数移动到区间[0-8], 原来的正数移动到[9-18] */ int current = (n % mod) / div + 9; buckets[current].add(n); &#125; // 将桶中的数放回数组 int index = 0; for(int i = 0; i &lt; 19; i++)&#123; if(!buckets[i].isEmpty())&#123; for(int n : buckets[i])&#123; arr[index++] = n; &#125; &#125; &#125; div *= 10; mod *= 10; &#125;&#125;private static int getMaxBit(int[] arr)&#123; int maxValue = arr[0], bit = 0; for(int n : arr)&#123; if(Math.abs(n) &gt; maxValue) maxValue = Math.abs(n); // 找出数组中绝对值最大的数 &#125; while(maxValue &gt; 0)&#123; bit++; maxValue /= 10; &#125; return bit;&#125; 分析 时间复杂度 基数排序平均时间复杂度为 $O(n k)$，最好时间复杂度为 $O(n k)$，最坏时间复杂度为 $O(n * k)$。 空间复杂度 基数排序需要额外 $k$ 个桶来存放所有的 $n$ 个元素，空间复杂度为 $O(n + k)$。 稳定性 对于数组中相同的元素，基数排序在每次向桶里放入元素和取出元素的时候不会改变它们的原有相对顺序，因此基数排序时稳定的。 总结&emsp;&emsp;计数排序、桶排序和基数排序达到线性时间复杂度的根本在于用空间换时间的策略，但是通过上面的具体解释也可以看出，它们通常只适用于整数元素序列的排序。如果是实数范围的元素很难进行排序。因此通常只在空间充足且对于整数元素排序的时候考虑它们。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"堆排序","slug":"HeapSort","date":"2019-08-24T05:57:26.000Z","updated":"2019-08-30T05:20:03.700Z","comments":false,"path":"2019/08/24/HeapSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/24/HeapSort/","excerpt":"","text":"基本思想&emsp;&emsp;堆排序是基于堆这种数据结构的一种排序方法。首先将待排序的数组(或序列)构造成完全二叉树，然后利用完全二叉树中父节点和孩子节点之间的关系，每次从当前二叉树中找出最大节点并将其移出未排序部分，达到排序的目的。首先介绍一下一些相关概念： 完全二叉树：对于一棵深度为 $h$ 的二叉树，如果除了最后一层外，其他每层的节点数都达到最大，且第 $h$ 层的节点都连续集中在最左边，那么这就是一棵完全二叉树，如下图所示： 堆：这里完整的叫法应当是二叉堆，它是一棵堆有序的完全二叉树。堆分为最大堆和最小堆，对于最大堆来说所有的父节点均大于等于两个孩子节点的值，因此根节点应当是最大值节点；相反，对于最小堆，所有的父节点均小于等于子节点的值，因此最小堆的根节点是最小值节点。 堆的顺序存储结构：堆是一棵完全二叉数，因此用数组这种顺序存储结构就可以表示： ①：按层序遍历的顺序在数组中存放堆的元素，下标0表示的元素是根节点，其子节点分别为下标1和下标2……依次类推； ②：节点 $i$ 如果存在左孩子，左孩子的下标为 $2i+1$；如果存在右孩子，右孩子的下标为 $2i+2$。 算法流程这里以一个长度为 $n$ 的数列arr为例 首先将待排序数组构建成一个堆，此时根节点(arr[0])应当为最大值，整个数组都处于无序区； 将堆中最大的元素移出。具体做法就是交换数组第一个元素 arr[0] 和 最后一个元素arr[n-1]，交换之后 arr[n-1] 位于有序区，不再参与后面的排序，此时无序区由 {arr[0]~arr[n-2]} 组成； 第二步之后，无序区的元素排列是违反堆的规则的，因此要重新对无序区进行调整得到一个包含 {arr[0]~arr[n-2]} 的新堆，然后交换 arr[0] 和 最后一个元素arr[n-2]， 并且将arr[n-2] 移到有序区，接下来对剩余元素重复相同的操作直至排序完成。 演示 代码实现堆排序中，关键的一个操作就是每次调整无序区的元素使其满足堆的规则，这个操作通过adjust()函数实现： 1234567891011private static void adjust(int[] arr, int i, int N)&#123; while(2*i+1 &lt; N)&#123; int j = 2 * i + 1; // 当前节点左孩子结点的索引 if(j+1 &lt; N &amp;&amp; (arr[j] &lt; arr[j+1])) j++; // 找到最大的孩子节点 if(arr[i] &gt;= arr[j]) break; // 表明根节点大于等于所有的孩子节点，不用交换 int temp = arr[i]; // 交换最大孩子节点和根节点 arr[i] = arr[j]; arr[j] = temp; i = j; &#125;&#125; 排序函数如下： 12345678910111213141516171819public static void heap_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int N = arr.length; for(int i = N/2; i &gt;= 0; i--)&#123; adjust(arr, i, N); // 通过调整使得初始堆有序 &#125; // 交换根节点(保存着最大元素)和最后一个孩子节点，并从堆中删除 while(N-- &gt; 0)&#123; int temp = arr[N]; arr[N] = arr[0]; arr[0] = temp; adjust(arr, 0, N); // 重新调整数组使得堆有序 &#125; &#125; 说明：首先对于原数组进行调整使得初始堆有序，然后通过while循环里的语句，首先交换当前堆中第一个元素和最后一个元素，并将最后一个元素移出堆(通过N—实现)，再重新调整堆使其有序。 分析 时间复杂度 堆排序遍历的次数就是由初始元素构成的完全二叉树的深度，其时间复杂度为 $O(n)$，最好和最差情况下也都为 $O(n)$。 空间复杂度 堆排序使用的额外空间跟数组长度无关，因此空间复杂度是 $O(1)$。 稳定性 如果存在重复元素，堆排序在交换堆顶元素和最后一个元素的时候，可能将原本靠后的元素前移，造成相同元素相对顺序的改变，因此堆排序是不稳定的。 堆排序是目前唯一能够同时最优地利用时间和空间的排序方法。 参考文献 一文搞定十大经典排序算法 《算法(第四版)》","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"快速排序","slug":"QuickSort","date":"2019-08-23T11:23:12.000Z","updated":"2019-08-30T05:20:03.710Z","comments":false,"path":"2019/08/23/QuickSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/23/QuickSort/","excerpt":"","text":"基本思想&emsp;&emsp;快速排序也是一种基于分治的排序算法，它的主要思想是将一个数组切分成两部分，将这两部分独立的进行排序。和归并排序不同的是：归并排序首先对两部分子数组进行排序，在子数组各自有序之后将他们合并为一个完整的有序数组；而快速排序在两个子数组均有序的时候整个数组也已经有序了。 &emsp;&emsp;快速排序的关键在于对数组的切分，这个过程通过一个切分元素(或者叫基准)来实现的，切分将数组划分为两部分，满足前一部分的元素均不大于切分元素，后一部分元素均不小于切分元素，这样在前后两部分都有序时整个数组自然而然就是有序的。 算法流程 首先选取切分元素(随计选取或者取数组第一个元素)； 从前向后遍历数组，找到一个大于切分元素的元素，接着从后向前遍历元素找到一个小于切分元素的元素，然后交换这两个元素的位置； 重复步骤2，直到遍历数组的两个指针相遇，交换此位置的元素和切分元素。这样整个数组就被切分元素分割成了两部分，满足前面的元素均不大于它，后面的元素均不小于它； 对两部分子数组递归地进行步骤1-3。 演示 代码实现&emsp;&emsp;上面讲到其实切分部分时算法的核心，因此首先给出切分数组的代码： 12345678910111213141516private static int partition(int[] arr, int lo, int hi)&#123; int i = lo, j = hi + 1; int v = arr[lo]; //指定切分元素为第一个元素 while(true)&#123; while(arr[++i] &lt; v)&#123; // 从第二个元素开始向后遍历，找到大于基准的元素 if(i == hi) break; &#125; while(arr[--j] &gt; v)&#123; if(j == lo) break; // 从最后一个元素向前遍历，找到小于基准的元素 &#125; if(i &gt;= j) break; // 前后便利的指针相遇，退出循环 swap(arr, i, j); // swap是交换数组元素的函数 &#125; swap(arr, lo, j); return j;&#125; 切分函数中使用了第一个元素作为切分元素，因此从第二个元素向后遍历，从最后一个元素向前遍历，并交换满足条件的元素。最差的情况就是其余所有元素都小于切分元素 (i==hi)，或者其余所有元素都大于切分元素(j==lo)，此时造成的结果是两部分切分非常不均匀，因此随机选取切分元素往往是更好的选择， 或者在排序之前将数组随机打乱。 &emsp;&emsp;下面是排序函数，可以看到排序的最主要的操作就是切分，然后不断地递归切分子数组 1234567891011121314public static void quick_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; sort(arr, 0, arr.length-1);&#125;private static void sort(int[] arr, int lo, int hi)&#123; if(lo &gt;= hi) return; // lo&gt;=hi说明当前部分已经不需要排序了 int j = partition(arr, lo, hi); // 切分数组 sort(arr, lo, j-1); // 递归地对两部分子数组进行排序 sort(arr, j+1, hi);&#125; 分析算法改进1. 随机选择切分元素 &emsp;&emsp;前面提到，在一些极端情况下(例如初始数组是倒序的)，选取第一个元素进行切分造成的结果就是每次切分的两部分非常不平衡。以倒序数组来说第一次切分后较长的一部分长度为 $n-1$ (假设数组总长度为n)，这样会造成没有很好的利用到分治带来的优势，降低算法性能。 因此一个改进措施就是随机选取切分元素，或者是选取切分元素前将数组随机打乱。 2. 切换到插入排序 &emsp;&emsp;对于小数组快速排序比插入排序慢，因此和归并排序一样，在子数组规模较小的时候切换为插入排序而不是递归地使用快速排序能够提高算法的效率。 3. 三路切分 &emsp;&emsp;实际排序中如果数组中包含大量重复元素，此时对于所有元素均相等的子数组，快速排序仍旧会不断地将其切分为更小的数组，这时候可以通过将数组划分为三部分来改进快速排序。 &emsp;① 思想 &emsp;&emsp;三路划分的思想是利用切分函数将待排序数组列划分为三部分：第一部分小于切分元素，第二部分等于切分元素，第三部分大于切分元素，接下来递归地对除了中间部分的其余两部份进行排序。这样如果数组中包含了大量重复元素，就可以避免对于重复部分进行切分排序的时间消耗。 &emsp;② 代码 12345678910111213private static void quick3way_sort(int[] arr, int lo, int hi)&#123; if(hi &lt;= lo) return; // lo&gt;=hi说明当前部分已经不需要切分排序了 int lt = lo, i = lo+1, gt = hi; int v = arr[lo]; // 切分元素 while(i &lt;= gt)&#123; if(arr[i] &lt; v) swap(arr, i++, lt++); else if(arr[i] &gt; v) swap(arr, i, gt--); else i++; &#125; // while循环执行完后，arr[lo...lt-1] &lt; a[lt...gt] &lt; a[gt+1...hi] quick3way_sort(arr, lo, lt-1); // 然后对除了切分部分外的两部分递归排序 quick3way_sort(arr, gt+1, hi);&#125; 说明：这里三路切分函数依旧使用第一个元素作为切分的基准，标记为v，lt用来存储切分部分的左边界，初始为数组首位置，gt存放切分部分的右边界，初始为数组的末尾。从第二个元素开始向后遍历并且和v比较：如果当前元素小于v，将其切分到左边并且切分左边界右移(lt++)；如果当前元素大于v，将其切分到右边并且切分部分右边界左移(gt--)，此时不执行i++的原因是不知道当前右边界元素和切分元素的大小关系，需要下一次循环中进行比较；如果当前元素等于切分元素，继续向后遍历。 算法性能分析 时间复杂度 快速排序的平均时间复杂度为 $O(nlogn)$。最好情况下，如果每次划分得当，递归树的深度就是 $logn$，时间复杂度为 $O(nlogn)$；最差情况下，每次划分都取到了数组中最大的(或最小的)元素作为切分元素，此时快速排序就退化为了冒泡排序，时间复杂度为 $O(n^2)$。 空间复杂度 快速排序主要的空间消耗是递归调用的空间占用。最好情况下，每次都能平均划分数组，空间复杂度为 $O(logn)$，最差情况下就是退化为冒泡排序，此时时间复杂度为 $O(n)$。 稳定性 在交换切分元素和遍历相遇点元素的时候，快速排序有可能打乱数组重复元素原有的顺序，因此快速排序是不稳定的。 参考文献 一文搞定十大经典排序算法 《算法(第四版)》","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"归并排序","slug":"MergeSort","date":"2019-08-23T07:48:12.000Z","updated":"2019-08-30T05:20:03.710Z","comments":false,"path":"2019/08/23/MergeSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/23/MergeSort/","excerpt":"","text":"基本思想&emsp;&emsp;用一句话描述归并排序就是：将两个有序的数组归并(Merge)为一个有序数组。归并排序是分治思想的一种典型应用。归并排序可以通过自顶向下的方式实现，也可以通过自底向上的方式实现。 自顶向下 自顶向下的归并排序首先将数组分成两个子数组，分别递归调用这两部分进行单独排序，最后合并子数组。下面的动图演示就是自顶向下的归并排序。 自底向上 和自顶向下的归并排序化整为零的思路不同，自底向上的归并排序循序渐进的解决问题。具体来说，首先对原数组进行两两归并(即数组中元素按顺序两两为一组，对每一组分别进行归并)，然后是四四归并……，一直到数组有序。 演示 自顶向下的归并排序 - 自底向上的归并排序 代码实现 归并函数 归并操作是归并排序的一个核心操作，其目的是将两个有序的子数组合并成一个有序数组。这里首先给出归并操作的函数。 12345678910111213141516171819private static void merge(int[] arr, int lo, int mid, int hi)&#123; /* lo: 归并部分的左边界 hi: 归并部分的右边界 mid: 两个归并部分的分界 */ int i = lo, j = mid + 1; // 复制arr[lo]... arr[hi]到辅助数组aux[]，aux[]是归并排序类的类私有变量 for(int k = lo; k &lt;= hi; k++)&#123; aux[k] = arr[k]; &#125; for(int k = lo; k &lt;= hi; k++)&#123; if(i &gt; mid) arr[k] = aux[j++]; // 左半边用尽则直接取右半边元素 else if(j &gt; hi) arr[k] = aux[i++]; // 右半边用尽则直接取左半边元素 else if(aux[j] &lt; aux[i]) arr[k] = aux[j++];// 左边元素大于右边元素， 取右边元素 else arr[k] = aux[i++]; // 右边元素大于等于左边元素，取左边元素 &#125;&#125; 自顶向下的排序 sortTD()函数是提供调用的归并排序函数，在其内部递归调用对子数组的排序函数 12345678910 // 自顶向下的归并排序 public static void sortTD(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125;aux = new int[arr.length]; // 给辅助数组分配和原数组大小相同的空间sort(arr, 0, arr.length - 1); // 递归排序函数的入口&#125; sort()函数是私有的，因为外部不需要调用，它不断的对自己进行递归调用达到化整为零的效果。 123456789101112131415161718private static void sort(int[] arr, int lo, int hi)&#123; /* lo: 排序数组左边界 hi: 排序数组右边界 */ if(hi &lt;= lo)&#123; return; &#125; int mid = (lo + hi) / 2; sort(arr, lo, mid); // 对左半边进行排序 sort(arr, mid+1, hi); // 对右半边进行排序 /* 由于左右两边此时都是有序的，所以当arr[mid] &lt;= arr[mid+1]时 表明数组整体也是有序的，不需要进行合并*/ if(arr[mid] &lt;= arr[mid+1])&#123; return; &#125; merge(arr, lo, mid ,hi); //合归并左右两部分&#125; 自底向上的排序 自底向上的归并排序代码较为简单，从第一轮每个子数组大小为1开始，每一轮的子数组大小翻倍。 12345678910111213141516// 自底向上的归并排序public static void sortBU(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int N = arr.length; aux = new int[N]; // 给辅助数组分配和原数组大小相同的空间 for(int sz = 1; sz &lt; N; sz += sz)&#123; //从两两归并开始， 不断增大归并的规模 for(int lo = 0; lo &lt; N-sz; lo += sz+sz)&#123; merge(arr, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1)); &#125; &#125;&#125; 分析 时间复杂度 采用了分治的思想后，归并排序的时间复杂度达到了$O(nlogn)$，并且最好最差情况下都是$O(nlogn)$。 空间复杂度 由于归并排序需要一个和待排序数组辅助数组来存放临时数组，因此其空间复杂度为$O(n)$，也就是需要的额外空间和原数组大小成正比。 稳定性 无论是自顶向下的归并排序还是自底向上的归并排序，对于相同的元素，排序都不会改变他们的相对顺序，因此归并排序是稳定的。 &emsp;&emsp;对于小规模问题，使用自顶向下的归并排序会频繁的递归调用排序函数，因此在使用归并排序时可以使用插入排序处理小规模的子数组，提高算法效率。 参考文献 《算法(第四版)》","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"希尔排序","slug":"ShellSort","date":"2019-08-22T11:06:43.000Z","updated":"2019-08-30T05:20:03.710Z","comments":false,"path":"2019/08/22/ShellSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/22/ShellSort/","excerpt":"","text":"基本思想 h有序数组 一个数组中任意间隔为 $h$ 的元素都是有序的，那这个数组就是h有序数组。如下图所示这个数组就是一个 $h$ 有序数组，其中 $h=4$。可以看到，虽然整个数组是乱序的，但任意相隔 $h=4$ 的元素都是有序的。 希尔排序 希尔排序的思想就是，首先让数组 $h$ 有序，然后不断减小 $h$ 的值。试想一下，当 $h=1$ 的时候，数组 $h$ 有序也就意味着任意元素和它相邻的元素是有序的，这也就意味着整个数组已经有序了。希尔排序是第一个突破 $O(n^2)$ 的排序算法。 算法流程 首先给 $h$设置一个初始值(通常可以去数组长度的一半)； 遍历数组，使得所有相隔 $h$ 的元素组成的子序列有序； 更新 $h$：$h=h/2$，重复步骤2，直到 $h&lt;1$，排序完成。 演示&emsp;&emsp;图中，第一遍排序时 $h=5$，第二遍 $h=2$，第三遍 $h=1$，第三遍排序完成后相邻两个元素有序，因此整个数组有序。 代码实现12345678910111213141516171819202122public static void shell_sort(int[] arr)&#123; int N = arr.length; // 数组为空或者长度为1不需要排序 if(arr == null || N &lt;= 1)&#123; return; &#125; int h = N; while(h &gt;=1)&#123; for(int i = h; i &lt; N; i++)&#123; // 对于当前的h, 让数组h有序 for(int j = i; j &gt;= h; j -= h)&#123; if(arr[j] &lt; arr[j-h])&#123; int temp = arr[j]; arr[j] = arr[j-h]; arr[j-h] = temp; &#125; &#125; &#125; h /= 2; // 缩减h的值 &#125;&#125; 分析 时间复杂度 之前在各种排序算法比较中虽然列出了希尔排序的复杂度，但实际情况是，希尔排序的性能与 $h$ 和 $h$ 之间的数学性质有很大的关系，有许多论文都在研究各种不同的 $h$ 递增序列，但到现在为止还无法证明某个序列是最好的。因此这里不深究其时间复杂度。 空间复杂度 希尔排序只使用了常数级别的额外空间，因此空间复杂度为 $O(n^2)$。 稳定性 希尔排序过程中各个子序列不影响，在排序中可能会造成相同元素相对位置的改变，因此是不稳定的。 参考文献 《算法(第四版)》","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"插入排序","slug":"InsertionSort","date":"2019-08-21T12:44:31.000Z","updated":"2019-08-30T05:20:03.700Z","comments":false,"path":"2019/08/21/InsertionSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/21/InsertionSort/","excerpt":"","text":"基本思想&emsp;&emsp;在玩扑克牌的时候，每当抽到一张牌的时候，就将其插入到手中已经有序的拍中，插入排序和这种整理扑克牌的思路很像。每遍历到一个新的元素就将其插入到它之前的所有元素中的合适位置，保证其之前的序列有序。 算法流程 第一趟排序：将第二个元素插入到前一个元素的合适位置； 第二趟排序：将第三个元素插入到前两个元素中的正确位置； 第三趟排序：将第四个元素插入到前三个元素中的正确位置；…… 第 $n$ 趟排序：将第 $n$ 个元素插入到前 $n-1$ 个元素中的正确位置。 可以通过下面的动图更直观地看到排序过程。显然，在每一轮排序之后，至少前 $n$ 个元素已经有序了。 演示 实现代码1234567891011121314151617public static void insertion_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int N = arr.length; for(int i = 1; i &lt; N; i++)&#123; // 每次循环将第j+1个元素插入到前j个元素中，保证前j+1个元素有序 int temp = arr[i], j = i; while(temp &lt; arr[j-1] &amp;&amp; j &gt; 0)&#123; // 大于当前元素的全部后移 arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125;&#125; 复杂度 时间复杂度 最好情况下：如果一开始数组就是有序的，那么插入排序只需要 $n-1$ 次比较，不需要交换，因此最好情况下时间复杂度为 $O(n)$; 最差情况下：如果一开始数组是倒序的，那么插入排序需要比较 $n(n-1)/2$ 次比较和 $n(n-1)/2$ 次交换，最差情况下时间复杂度为 $O(n^2)$; 平均来看，插入排序的时间复杂度为 $O(n^2)$。 空间复杂度：插入排序同样只需要常熟级的额外空间，因此空间复杂度为 $O(1)$。 稳定性&emsp;&emsp;插入排序不会改变数组中相同元素的相对位置，因此是稳定的。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"冒泡排序","slug":"bubbleSort","date":"2019-08-20T11:45:21.000Z","updated":"2019-08-30T05:20:03.710Z","comments":false,"path":"2019/08/20/bubbleSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/20/bubbleSort/","excerpt":"","text":"基本思想&emsp;&emsp;冒泡排序是基于比较和交换的排序算法。它重复地比较两两元素，如果他们顺序错误就进行交换，直到没有交换发生表明数组已经有序。 &emsp;&emsp;之所以称为冒泡排序是因为在比较排序过程中，较小的元素会慢慢的前移，类似于碳酸饮料中二氧化碳的气泡上浮过程。 算法流程 比较相邻元素，如果第一个元素比第二个元素大则交换它们的位置； 从开始第一对到最后一对的每一对相邻元素做步骤1同样的工作，这一步之后最后一个元素应该是最大值； 针对所有的元素重复以上的步骤；(实质上第 $i$ 趟排序之后至少最后 $i$ 个元素已经有序了，因此只需要对前 $n-i$ 个元素进行以上步骤)； 重复步骤1~3，直到排序完成。 演示 实现代码冒泡排序 Java 版本的实现如下(代码只给出了排序函数的实现):123456789101112131415161718public static void bubble_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int N = arr.length; for(int i = 0; i &lt; N - 1; i++)&#123; for(int j = 0; j &lt; N - i - 1; j++)&#123; // 如果相邻元素顺序不对则交换 if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125;&#125; 优化：实质上，如果某一次遍历过程中没有发生元素交换就说明数组已经有序，此时就可以提前终止排序。因此，可以在每趟排序前设置一个flag，初始设置为false，如果发生了元素交换则更新flag=true，这样本趟排序完成后如果flag仍为false说明没有元素交换，则退出排序。代码如下：1234567891011121314151617181920212223public static void bubble_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; int N = arr.length; for(int i = 0; i &lt; N - 1; i++)&#123; boolean flag = false; // 标记本趟排序是否发生元素交换 for(int j = 0; j &lt; N - i - 1; j++)&#123; // 如果相邻元素顺序不对则交换 if(arr[j] &gt; arr[j+1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; flag = true; &#125; &#125; if(!flag)&#123; // 一趟排序完成后flag仍为false，说明数组已经有序 break; &#125; &#125;&#125; 复杂度 时间复杂度最好情况下：初始时刻数组就是有序的，在设置了标记的时候，第一趟排序后排序就终止了，因此只需要进行$n-1$次比较，不需要进行交换，最好的时间复杂度为 $O(n)$。(但是如果不设置标记，算法仍旧需要比较 $n(n-1)/2$ 次，时间复杂度为 $O(n-1)$)最坏情况下：初始时刻数组是倒序的，这样算法需要进行 $n(n-1)/2$ 次比较和 $n(n-1)/2$ 次交换，时间复杂度为 $O(n^2)$ 。 空间复杂度：冒泡排序仅在交换元素的时候使用了常数级别的额外空间，因此空间复杂度为 $O(1)$。 稳定性冒泡排序依据相邻元素的大小关系来决定是否交换，因此排序不会改变两个相同元素的顺序，所以是稳定的。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"简单选择排序","slug":"SelectionSort","date":"2019-08-20T08:41:51.000Z","updated":"2019-08-30T05:20:03.710Z","comments":false,"path":"2019/08/20/SelectionSort/","link":"","permalink":"https://MorningHi.github.io/2019/08/20/SelectionSort/","excerpt":"","text":"基本思想&emsp;&emsp;简单选择排序是一种简单并且非常直观的排序算法。它的思想是每次从未排序序列中找到最小值，然后将其放到已排序序列的末尾，重复这一过程直到不存在未排序元素。 算法流程以长度为 $n$ 的数组为例： 第一趟排序：从第一个元素开始遍历整个数组，找出最小值，和第一个元素交换； 第二趟排序：找出第二个元素到第 $n$ 个元素中的最小值，和第二个元素交换； 第三趟排序：找出第三个元素到第 $n$ 个元素中的最小值，和第三个元素交换；…… 第 $n-1$ 趟排序：将第 $n$-1 和第 $n$ 个元素正确排序，排序完成。 演示 代码实现简单选择排序 Java 版本的实现如下(代码只给出了排序函数的实现): 123456789101112131415161718public static void selection_sort(int[] arr)&#123; // 数组为空或者长度为1不需要排序 if(arr == null || arr.length &lt; 2)&#123; return; &#125; for(int i = 0; i &lt; arr.length - 1; i++)&#123; int min = i; // 记录最小值的索引 for(int j = i + 1; j &lt; arr.length; j++)&#123; if(arr[j] &lt; arr[min])&#123; min = j; &#125; &#125; // 交换当前值和最小值 int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125;&#125; 复杂度 时间复杂度 最好情况下：初始数组就是有序的，此时简单选择排序需要进行 $n(n-1)/2$ 次比较，不需要交换元素，时间复杂度为 $O(n^2)$;最差情况下：初始数组是倒序的(例如需要从小到大排序但初始数组是从大到小排列的)，此时简单选择排序需要进行 $n(n-1)/2$ 次比较和 $3(n-1)$ 次交换，时间复杂度也是$O(n^2)$;因此，简单选择排序需要进行的比较次数与初始元素排列情况无关，其平均时间复杂度为$O(n^2)$，最好的情况时间复杂度为$O(n^2)$，最坏情况时间复杂度为$O(n^2)$。 空间复杂度：简单选择排序仅需要在交换元素的时候使用额外的常数空间，因此空间复杂度为$O(1)$。 稳定性&emsp;&emsp;简单选择排序是一种不稳定的排序算法。例如对{2，4，2，1}进行排序，第一轮比较的时候第一个 “2” 会和 “1” 交换位置，破坏原有的两个 “2” 的顺序，因此它是不稳定的。 参考 一文搞定十大排序算法 《算法(第四版)》","categories":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"},{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[{"name":"算法基础","slug":"算法基础","permalink":"https://MorningHi.github.io/categories/算法基础/"}]},{"title":"回环变位(Circular Rotation)","slug":"circularRotation","date":"2018-08-13T05:21:24.000Z","updated":"2019-08-20T02:27:27.810Z","comments":false,"path":"2018/08/13/circularRotation/","link":"","permalink":"https://MorningHi.github.io/2018/08/13/circularRotation/","excerpt":"","text":"回环变位：如果字符串s中的字符循环移动任意位置之后能够得到另一个字符串 t，那么 s 称为 t 的回环变位(Circular Rotation)。例如，”ACTGACG” 就是 “TGACGAC” 的一个回环变位。 一般的实现思想 利用循环的方式遍历字符串t,从循环次数i处将字符串t分成两个字串后交换顺序拼接成一个新的字符串，比较新的s和新的字符串是否相等。 123456789101112131415161718public static boolean isCircularRotation1(String s, String t)&#123; if(s.length() != t.length()) //字符串长度不等则没必要再比较，直接返回false return false; else &#123; int N = s.length(); System.out.println(N); for(int i=0; i&lt;=N; i++) &#123; String subT1 = t.substring(0, i); //在索引i处分割字符串t String subT2 = t.substring(i, N); if(s.equals(subT2 + subT1)) //交换顺序连接分割后的字串 return true; &#125; return false; &#125;&#125; 让代码简单点《算法》(Algorithms)这本书的习题中关于回环变位给了这么一行提示：答案只需要一行用到 indexOf()、length() 和字符串连接的代码。 怎么实现呢？——将 t 和 t 自身连接，这样如果 t 是 s 的回环变位，那么s肯定是 “t+t” 的一个子串！ 方法如下：1234public static boolean isCircularRotation(String s, String t)&#123; return (s.length() == t.length()) &amp;&amp; ((t + t).indexOf(s) &gt; 0);&#125; 其中关于字符串对象的方法的具体使用可以参考 javaAPI文档，里面介绍的很详细。","categories":[{"name":"Java","slug":"Java","permalink":"https://MorningHi.github.io/categories/Java/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://MorningHi.github.io/tags/字符串/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://MorningHi.github.io/categories/Java/"}]}]}