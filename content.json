{"meta":{"title":"Something for Nothing","subtitle":"","description":"","author":"Rezero","url":"https://MorningHi.github.io"},"pages":[{"title":"","date":"2019-07-29T07:49:29.191Z","updated":"2019-07-29T07:49:29.191Z","comments":true,"path":"404.html","permalink":"https://MorningHi.github.io/404.html","excerpt":"","text":""},{"title":"about me","date":"2017-06-23T07:11:57.000Z","updated":"2019-07-29T07:49:29.196Z","comments":true,"path":"about/index.html","permalink":"https://MorningHi.github.io/about/index.html","excerpt":"","text":"一只喜欢看日落的猴子软件没学好，硬件学不会的菜鸟 From XDU QQ:1432409554E-mail:rezero_liu@163.com"},{"title":"tags","date":"2017-06-22T16:58:21.000Z","updated":"2019-07-29T07:49:29.197Z","comments":false,"path":"tags/index.html","permalink":"https://MorningHi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"测试","slug":"测试-1","date":"2019-08-03T05:24:50.000Z","updated":"2019-08-03T05:24:50.356Z","comments":false,"path":"2019/08/03/测试-1/","link":"","permalink":"https://MorningHi.github.io/2019/08/03/测试-1/","excerpt":"","text":"","categories":[{"name":"分类1","slug":"分类1","permalink":"https://MorningHi.github.io/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"https://MorningHi.github.io/categories/分类1/分类2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://MorningHi.github.io/tags/标签1/"},{"name":"标签2","slug":"标签2","permalink":"https://MorningHi.github.io/tags/标签2/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"https://MorningHi.github.io/categories/分类1/"},{"name":"分类2","slug":"分类1/分类2","permalink":"https://MorningHi.github.io/categories/分类1/分类2/"}]},{"title":"测试","slug":"测试","date":"2019-08-03T05:23:21.000Z","updated":"2019-08-03T05:24:30.017Z","comments":false,"path":"2019/08/03/测试/","link":"","permalink":"https://MorningHi.github.io/2019/08/03/测试/","excerpt":"","text":"","categories":[{"name":"机器学习","slug":"机器学习","permalink":"https://MorningHi.github.io/categories/机器学习/"}],"tags":[{"name":"ANN","slug":"ANN","permalink":"https://MorningHi.github.io/tags/ANN/"}],"keywords":[{"name":"机器学习","slug":"机器学习","permalink":"https://MorningHi.github.io/categories/机器学习/"}]},{"title":"test","slug":"test","date":"2019-08-03T05:12:16.000Z","updated":"2019-08-03T05:16:59.411Z","comments":true,"path":"2019/08/03/test/","link":"","permalink":"https://MorningHi.github.io/2019/08/03/test/","excerpt":"","text":"zheshiyige测试页面","categories":[{"name":"算法","slug":"算法","permalink":"https://MorningHi.github.io/categories/算法/"}],"tags":[{"name":"SVM","slug":"SVM","permalink":"https://MorningHi.github.io/tags/SVM/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://MorningHi.github.io/categories/算法/"}]},{"title":"快速排序算法——python实现","slug":"quickSort","date":"2018-05-10T09:11:36.000Z","updated":"2019-07-29T07:49:29.195Z","comments":true,"path":"2018/05/10/quickSort/","link":"","permalink":"https://MorningHi.github.io/2018/05/10/quickSort/","excerpt":"","text":"快速排序的思想 首先在数组中任意选取一个数（通常选第一个数）作为标志数据，通过比较将有比它小的数全放到它前面，比它大的数全放到它后面，这样完成一趟排序。 一趟排序的流程为： 初始时i=0, j=N-1。其中N为数组长度； 选择标志数据key，通常设置key = Array[0]； 从数组尾部向前遍历（j –），找到第一个比key小的数A[j]，交换A[i]和A[j]的位置； 从数组首部向后遍历（i ++），找到第一个比key大的数A[i]，交换A[i]和A[j]的位置； 重复步骤3和4直到i=j。 一趟排序之后标志数据将数组分成了左右两部分，左边的数应当都小于它而右边的数都比它大。再利用递归的思想，对左右两部分分别进行同样的操作，最终实现对数组的排序。 123456789101112131415161718192021222324252627282930#快速排序的递归实现def quickSort(arr, low, high): i = low j = high if i &gt;= j: return arr key = arr[i] #设置标志数据 while i &lt; j: #从尾部向前遍历，找到第一个比key小的数 while arr[j] &gt;= key and i &lt; j: j = j - 1 arr[i] = arr[j] #从首部部向前遍历，找到第一个比key大的数 while arr[i] &lt;= key and j &gt; i: i = i + 1 arr[j] = arr[i] arr[i] = key #一轮之后数组分成了左右两部分，用同样的思想分别进行递归 quickSort(arr, low, i-1) quickSort(arr, i+1, high)#测试函数def test(): Arr = [7, 5, 4, 80, 3, 2, 19, 8, 11, 23, 4, 6, 1, 53, 27, 9, 20] quickSort(Arr, 0, len(Arr) - 1) print(Arr)if __name__ == '__main__': test() 快速排序算法的平均时间复杂度为O(nlgn)，标志数据的位置选择会影响算法的效率，最坏情况下时间复杂度可能为O(N^2)。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://MorningHi.github.io/tags/python/"}],"keywords":[]},{"title":"回环变位(Circular Rotation)","slug":"circularRotation","date":"2017-08-13T05:21:24.000Z","updated":"2019-07-29T07:49:29.192Z","comments":true,"path":"2017/08/13/circularRotation/","link":"","permalink":"https://MorningHi.github.io/2017/08/13/circularRotation/","excerpt":"","text":"回环变位：如果字符串s中的字符循环移动任意位置之后能够得到另一个字符串 t，那么 s 称为 t 的回环变位(Circular Rotation)。例如，”ACTGACG” 就是 “TGACGAC” 的一个回环变位。 一般的实现思想 利用循环的方式遍历字符串t,从循环次数i处将字符串t分成两个字串后交换顺序拼接成一个新的字符串，比较新的s和新的字符串是否相等。 123456789101112131415161718public static boolean isCircularRotation1(String s, String t)&#123; if(s.length() != t.length()) //字符串长度不等则没必要再比较，直接返回false return false; else &#123; int N = s.length(); System.out.println(N); for(int i=0; i&lt;=N; i++) &#123; String subT1 = t.substring(0, i); //在索引i处分割字符串t String subT2 = t.substring(i, N); if(s.equals(subT2 + subT1)) //交换顺序连接分割后的字串 return true; &#125; return false; &#125;&#125; 让代码简单点《算法》(Algorithms)这本书的习题中关于回环变位给了这么一行提示：答案只需要一行用到 indexOf()、length() 和字符串连接的代码。 怎么实现呢？——将 t 和 t 自身连接，这样如果 t 是 s 的回环变位，那么s肯定是 “t+t” 的一个子串！ 方法如下：1234public static boolean isCircularRotation(String s, String t)&#123; return (s.length() == t.length()) &amp;&amp; ((t + t).indexOf(s) &gt; 0);&#125; 其中关于字符串对象的方法的具体使用可以参考 javaAPI文档，里面介绍的很详细。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[]},{"title":"myChat","slug":"myChat","date":"2017-06-23T09:32:35.000Z","updated":"2019-07-29T07:49:29.193Z","comments":true,"path":"2017/06/23/myChat/","link":"","permalink":"https://MorningHi.github.io/2017/06/23/myChat/","excerpt":"","text":"一个使用java编写的基于UDP协议简单聊天程序。主要包括四个类：发送类、接收类、GUI和主类。能够实现同一局域网下的两台主机相互聊天。 程序源代码如下：1. 发送类(Sender)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package com.zero;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.net.*;public class Sender extends ChatWindow implements Runnable&#123; private DatagramSocket ds; //发送数据包的套接字 private int sendPort; //发送端口 public Sender(DatagramSocket ds, int port, String windowName) &#123; super(windowName); this.ds = ds; this.sendPort = port; &#125; public void run() //发送线程 &#123; try &#123; myEvent(); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public void send_mess(String message) &#123; try &#123; byte[] by = message.getBytes(); //将消息转换为比特数组 DatagramPacket dp = new DatagramPacket(by, by.length, InetAddress.getByName(\"127.0.0.1\"), sendPort); //封装数据包 ds.send(dp); //发送数据包 &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public void myEvent() &#123; //窗口点击关闭事件 f.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123; ds.close(); //关闭服务 System.exit(0); &#125; &#125;); sendBut.addActionListener(new ActionListener() //给发送按钮添加事件 &#123; @Override public void actionPerformed(ActionEvent e) &#123; try &#123; String mess = editArea.getText(); //获取输入聊天消息 send_mess(mess); chatArea.append(mess+System.getProperty(\"line.separator\")); &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; editArea.setText(null); &#125; &#125; &#125;); editArea.addKeyListener(new KeyAdapter() &#123; public void keyPressed(KeyEvent e) &#123; try &#123; if(e.getKeyCode()==KeyEvent.VK_ENTER) &#123; String mess = editArea.getText(); //获取输入聊天消息 send_mess(mess); chatArea.append(mess+System.getProperty(\"line.separator\")); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; finally &#123; editArea.setText(null); &#125; &#125; &#125;); &#125;&#125; 2. 接收类(Receiver)12345678910111213141516171819202122232425262728293031323334package com.zero;import java.net.DatagramPacket;import java.net.DatagramSocket;public class Receiver implements Runnable&#123; private DatagramSocket ds; //接收数据报的套接字 public Receiver(DatagramSocket ds) &#123; this.ds = ds; &#125; public void run() //实现run()方法 &#123; try &#123; while(true) &#123; byte[] buf = new byte[1024]; DatagramPacket dp = new DatagramPacket(buf, buf.length); ds.receive(dp); //接收数据包 String ip = dp.getAddress().getHostAddress(); String mess = new String(dp.getData(), 0, dp.getLength()); ChatWindow.chatArea.append(\"From ip:\"+ip+\",message:\"+mess+System.getProperty(\"line.separator\")); &#125; &#125; catch(Exception ex) &#123; ex.printStackTrace(); &#125; &#125;&#125; 3. GUI界面类12345678910111213141516171819202122232425262728293031323334353637383940package com.zero;import java.awt.Button;import java.awt.FlowLayout;import java.awt.Frame;import java.awt.TextArea;public class ChatWindow&#123; protected Frame f; protected Button sendBut; protected static TextArea editArea, chatArea; ChatWindow() &#123; init(\"hahahaha\"); &#125; ChatWindow(String windowName) &#123; init(windowName); &#125; public void init(String windowName) //窗体初始化 &#123; f = new Frame(windowName); f.setBounds(300, 100, 400, 500); f.setLayout(new FlowLayout()); sendBut = new Button(\"send\"); editArea = new TextArea(8, 50); chatArea = new TextArea(16, 50); chatArea.setEditable(false); //chatArea为聊天消息显示区，不可编辑 f.add(chatArea); //添加组件 f.add(editArea); f.add(sendBut); f.setVisible(true); &#125;&#125; 4. 主类(ChatDemo)说明：ChatDemo类只是一端的聊天程序，是基于多线程的程序，发送和接收个占用一个线程。要实现聊天只需要在局域网中的另一台设备上再启动一个主类并且修改相应的ip地址以及端口号即可。1234567891011121314151617181920package com.zero;import java.net.DatagramSocket;public class ChatDemo&#123; public static void main(String[] args) throws Exception &#123; // TODO Auto-generated method stub //new ChatWindow(\"chatwindow1\"); DatagramSocket sendSocket = new DatagramSocket(); DatagramSocket receiveSocket = new DatagramSocket(10000); //监听端口号 new Thread(new Sender(sendSocket, 10001, \"Chatwindow of A\")).start(); //启动发送线程，10001为发送端口号 new Thread(new Receiver(receiveSocket)).start(); //启动接收线程 &#125;&#125; 这个程序比较简单，我也省略了线程同步的步骤。另外只能在同一个局域网下的两台设备上运行，至于为什么不能在不同局域网间通信这个问题涉及到网络映射等问题，才学疏浅的我现在还不能给出解决，很遗憾。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://MorningHi.github.io/tags/java/"}],"keywords":[]},{"title":"北国的秋","slug":"myfirst-blog","date":"2017-06-13T14:24:30.000Z","updated":"2019-07-29T07:49:29.194Z","comments":true,"path":"2017/06/13/myfirst-blog/","link":"","permalink":"https://MorningHi.github.io/2017/06/13/myfirst-blog/","excerpt":"","text":"假装我是一个北方人北国的秋似乎不太礼貌没给世界半点预告就迫不及待地撞进夏的余温里 天边的阳光少了一丝热烈或许是它不太喜欢这个季节于是我发现——它离地平线又近了一点都不顾身边几片云朵对它的留恋因为，在那遥远天边还有晚霞同他做伴让它即使离开云朵也不会觉得孤单 桌上的咖啡还腾着热气但总感觉缺了一首乐曲突然意识到——昨天窗外树荫中的格外聒噪原来是它们告别的郑重宣告但是，昨晚入梦前分明还分明还和蟋蟀的长谈遇见不知今晚还会不会听到一句再见 窗角的梧桐叶泛了点黄将要为这个季节换身新装我想它清楚——下面柏油马路才是自己最后的归宿可那又如何？即使离开也得秀出飘逸的舞步好来迎接那阵轻风的吻度“嘘——我的舞会将要落下帷幕” 北国的秋似乎不太礼貌那漫天夕阳还未褪去它就迫不及待地撞进夏的余温里…… Rezero 2015.9","categories":[],"tags":[{"name":"故事和酒","slug":"故事和酒","permalink":"https://MorningHi.github.io/tags/故事和酒/"}],"keywords":[]}]}