{"meta":{"title":"Something for Nothing","subtitle":"","description":"","author":"Rezero","url":"https://MorningHi.github.io"},"pages":[{"title":"","date":"2019-07-29T07:49:29.191Z","updated":"2019-07-29T07:49:29.191Z","comments":true,"path":"404.html","permalink":"https://MorningHi.github.io/404.html","excerpt":"","text":""},{"title":"About me","date":"2017-06-23T07:11:57.000Z","updated":"2019-08-03T06:35:06.192Z","comments":true,"path":"about/index.html","permalink":"https://MorningHi.github.io/about/index.html","excerpt":"","text":"一只喜欢看日落的猴子 From XDU"},{"title":"tags","date":"2017-06-22T16:58:21.000Z","updated":"2019-08-03T05:57:59.411Z","comments":false,"path":"tags/index.html","permalink":"https://MorningHi.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"快速排序算法——python实现","slug":"quickSort","date":"2018-11-10T09:11:36.000Z","updated":"2019-08-03T07:08:57.157Z","comments":true,"path":"2018/11/10/quickSort/","link":"","permalink":"https://MorningHi.github.io/2018/11/10/quickSort/","excerpt":"","text":"快速排序的思想 首先在数组中任意选取一个数（通常选第一个数）作为标志数据，通过比较将有比它小的数全放到它前面，比它大的数全放到它后面，这样完成一趟排序。 一趟排序的流程为： 初始时i=0, j=N-1。其中N为数组长度； 选择标志数据key，通常设置key = Array[0]； 从数组尾部向前遍历（j - -），找到第一个比key小的数A[j]，交换A[i]和A[j]的位置； 从数组首部向后遍历（i ++），找到第一个比key大的数A[i]，交换A[i]和A[j]的位置； 重复步骤3和4直到i=j。 一趟排序之后标志数据将数组分成了左右两部分，左边的数应当都小于它而右边的数都比它大。再利用递归的思想，对左右两部分分别进行同样的操作，最终实现对数组的排序。 123456789101112131415161718192021222324252627282930#快速排序的递归实现def quickSort(arr, low, high): i = low j = high if i &gt;= j: return arr key = arr[i] #设置标志数据 while i &lt; j: #从尾部向前遍历，找到第一个比key小的数 while arr[j] &gt;= key and i &lt; j: j = j - 1 arr[i] = arr[j] #从首部部向前遍历，找到第一个比key大的数 while arr[i] &lt;= key and j &gt; i: i = i + 1 arr[j] = arr[i] arr[i] = key #一轮之后数组分成了左右两部分，用同样的思想分别进行递归 quickSort(arr, low, i-1) quickSort(arr, i+1, high)#测试函数def test(): Arr = [7, 5, 4, 80, 3, 2, 19, 8, 11, 23, 4, 6, 1, 53, 27, 9, 20] quickSort(Arr, 0, len(Arr) - 1) print(Arr)if __name__ == '__main__': test() 快速排序算法的平均时间复杂度为O(nlgn)，标志数据的位置选择会影响算法的效率，最坏情况下时间复杂度可能为O(N^2)。","categories":[{"name":"算法","slug":"算法","permalink":"https://MorningHi.github.io/categories/算法/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://MorningHi.github.io/tags/排序/"}],"keywords":[{"name":"算法","slug":"算法","permalink":"https://MorningHi.github.io/categories/算法/"}]},{"title":"回环变位(Circular Rotation)","slug":"circularRotation","date":"2018-08-13T05:21:24.000Z","updated":"2019-08-03T07:06:55.816Z","comments":false,"path":"2018/08/13/circularRotation/","link":"","permalink":"https://MorningHi.github.io/2018/08/13/circularRotation/","excerpt":"","text":"回环变位：如果字符串s中的字符循环移动任意位置之后能够得到另一个字符串 t，那么 s 称为 t 的回环变位(Circular Rotation)。例如，”ACTGACG” 就是 “TGACGAC” 的一个回环变位。 一般的实现思想 利用循环的方式遍历字符串t,从循环次数i处将字符串t分成两个字串后交换顺序拼接成一个新的字符串，比较新的s和新的字符串是否相等。 123456789101112131415161718public static boolean isCircularRotation1(String s, String t)&#123; if(s.length() != t.length()) //字符串长度不等则没必要再比较，直接返回false return false; else &#123; int N = s.length(); System.out.println(N); for(int i=0; i&lt;=N; i++) &#123; String subT1 = t.substring(0, i); //在索引i处分割字符串t String subT2 = t.substring(i, N); if(s.equals(subT2 + subT1)) //交换顺序连接分割后的字串 return true; &#125; return false; &#125;&#125; 让代码简单点《算法》(Algorithms)这本书的习题中关于回环变位给了这么一行提示：答案只需要一行用到 indexOf()、length() 和字符串连接的代码。 怎么实现呢？——将 t 和 t 自身连接，这样如果 t 是 s 的回环变位，那么s肯定是 “t+t” 的一个子串！ 方法如下：1234public static boolean isCircularRotation(String s, String t)&#123; return (s.length() == t.length()) &amp;&amp; ((t + t).indexOf(s) &gt; 0);&#125; 其中关于字符串对象的方法的具体使用可以参考 javaAPI文档，里面介绍的很详细。","categories":[{"name":"Java","slug":"Java","permalink":"https://MorningHi.github.io/categories/Java/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://MorningHi.github.io/tags/字符串/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"https://MorningHi.github.io/categories/Java/"}]}]}